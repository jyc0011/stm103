/* This code support for STM32F103C8T6 and STM32F107VCT.
 *
 * [NOTE] PB3/4 should be remapped for STM32F103C8T6
 *	//the default function of STM32F103 Module Pin6 (PB3) is JTDO.
	//For assigning it to GPIO PB3 or TIM2-CH2, we should remap it.
	//After setting PINs, we should remap for PB3 and PB4 pins
	//PB3, PB4 ==> GPIO ==> TIM
	//(Need Remap for PB3 and PB4)
	// GPIO_PartialRemap1_TIM2 : PA14 and PB3*
	// GPIO_PartialRemap2_TIM2 : PB10 and PB11
	// GPIO_FullRemap_TIM2 : PA15,PB3,PB10 and PB11
	// GPIO_PartialRemap_TIM3 : PB4* and PB5
	// GPIO_FullRemap_TIM3 : PC6,7,8,9
	// GPIO_Remap_SWJ_JTAGDisable: PB3/PB4 Remap to GPIO

    //GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE); //PB3->GPIO, PB4->GPIO. JTAG-DP Disable
    //GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE); //Remap for TIM2 : for PB3* and PA14
    //GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE);  //Remap for TIM3 : for PB4* and PB5
     *
 * These two processors has different pinout and clocks.
 * Thus we should add the folloging word in the compilers preprocessor configuration
 * (1) STM32F103C8T6 : MAX72MHz
  *       STM32F10X_MD  ---- MD means Medium Density Flash Memory
 *       USE_STDPERIPH_DRIVER
 *       _ASSEMBLY_
 *       *** Also we need "C:\CooCox\CoIDE\workspace\stm103datong\cmsis_boot\startup\startup_stm32f10x_md.c"
 *       *** 10000,5000
 *       STM32F10x_MD_64.elf
 * (2) STM32F107VCT : MAX72MHz -- See AN3411 for PTP
  *       STM32F10X_CL  ---- CL means Connectivity Lineup Device.
 *       USE_STDPERIPH_DRIVER
 *       _ASSEMBLY_
 *       *** Also we need "C:\CooCox\CoIDE\workspace\stm103datong\cmsis_boot\startup\startup_stm32f10x_cl.c"
 *		 *** 40000,10000
 *		 STM32F10x_CL_256.elf
 *		 ** Should increase the stack size from 100 to 200 in startup_stm32f10x_cl.c
 *
 * (3) STM32F103RCT6 : MAX72MHz
  *       STM32F10X_HD  ---- HD means High Density Flash Memory 256~
 *       USE_STDPERIPH_DRIVER
 *       _ASSEMBLY_
 *       *** Also we need "C:\CooCox\CoIDE\workspace\stm103datong\cmsis_boot\startup\startup_stm32f10x_hd.c"
 *		 *** 40000,c000
 *		 STM32F10x_HD_256.elf
 *		 ** Should increase the stack size from 100 to 200 in startup_stm32f10x_hd.c
 *
 [REF] : Ethernet : Dendos in github
 *
 * i) For using usart for debugging, set proper DEBUG_UART_INDEX in yInc.h
/**
 *
 * [NOTE WE ADD]
 * stm32f10x_gpio.c : void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
 * stm32f10x_i2c.c  : void I2C_Send8bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);
  */
////// The above comment is automatically generated by CoIDE ///////////////////

// REF for HAL CubeMx : github- STMicroelectronics/STMCubeF1

//STM32F401RET : Max84MHz
//+--------+-----------+-----------+-----------+---------+---------+-------------------------+----------+-----------+--------------+
//|        |401-M34    |401-M35    | 407-M35   | 407-M36 |103      |103LEAN                  | 103      | 103 BLDC  |103RCT/LCD    |103RCT/BGC
//+--------+-----------+-----------+-----------+---------+---------+-------------------------+----------+-----------+--------------+
//                                                       |M35,M37  | M78                     | M78      | M78       | M79          |M79
//                                                       |M39,~M70 |                         | Add32768 |           |
//+--------+-----------+-----------+-----------+---------+---------+-------------------------+----------+-----------+--------------+
//| ULED   | PB14      |PC4        |PE15       | <==     | PC14    |PC13                     | PC13     | PC13/PC14 |PC13          |PC5
//+--------+-----------+-----------+-----------+---------+---------+-------------------------+----------+-----------+--------------+
//| BUTTON |           |PC5(H)     |PD11(index)| PD11(L) | PC15    |PA15                     | PA15     | NC        |PA15          |PC3
//+--------+-----------+-----------+-----------+---------+---------+-------------------------+----------+-----------+------------+
//| BEEP   |           |PB13       |PD14       | <==     | PC13    |PC13(Shared with ULED)   | <-       |PB5        |PC12          |PC13
//+--------+-----------+-----------+-----------+---------+---------+-------------------------+----------+-----------+-------------+
//| QEI    |           |PB0,1,12   |PD12,13,11 | PD12,13 |                                                          |NC            |NC
//+--------+-----------+-----------+-----------+---------+---------+-------------------------+----------+-----------+--------------+
//|DGBUART |           |           |           |         |         |UART1(PA10/9)                                   |UART1(PA10/9) |UART3(PC11/10)
//+--------+-----------+-----------+-----------+---------+---------+-------------------------+----------+-----------+--------------+
//|I2C     |           |           |           |         |         |I2C1(PB7/6)                                     |I2C1 (PB7/6)  | I2C1 (PB7/6)
//+--------+-----------+-----------+-----------+---------+---------+-------------------------+----------+--------
//|                                                      |M70~main pinout changed. comply to M35.
//+--------+-----------+-----------+-----------+---------+---------+-------------------------+
//*H= Active High/L=Active Low
//TBD

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "yInc.h"
#if ((PROCESSOR == PROCESSOR_STM32F103C8T6) || (PROCESSOR == PROCESSOR_STM32F103RCT6)  || (PROCESSOR == PROCESSOR_STM32F107VCT))
#include "stm32f10x.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_rcc.h"//Reset and Clock Control
#include "stm32f10x_tim.h"
#include "stm32f10x_exti.h"
#include "misc.h"
#include "core_cm3.h"
#include "ySpiDrv.h"
//#include "lwip/include/lwipopts.h"
#else
printf("Not Support\r\n");
#endif
//#if (PROCESSOR == PROCESSOR_STM32F103C8T6)
//#define HSE_VALUE    ((uint32_t)8000000) //< Value of the External oscillator in Hz. See also cmsis_boot/stm32f10x.h
//#else
//#define HSE_VALUE    ((uint32_t)25000000) //< Value of the External oscillator in Hz. See also cmsis_boot/stm32f4xx.h
//#endif
//#include <semihosting.h>
//#include "lwipopts.h"

//ULED - PB15

//#undef FLASH_LATENCY_0
//#define FLASH_LATENCY_0 FLASH_LATENCY_5

//#include "ethernet_board_support.h"

//============Globals ======================
volatile uint32_t gTimingDelay =0;
volatile uint32_t g_tickCnt=0;
uint32_t g_tickEvent=0;
volatile u8 g_mac_addr[6];
I2C_TypeDef *gI2Cx;
uint32_t randNum32;
//============ Extern Variables ======================
extern bool g_OzLED_InitDone;
extern unsigned char g_bI2CModuleConfigDone;
extern unsigned char g_ip_addr3;//in netconf.c
extern int g_INT2_LIS3DH, g_INT1_LIS3DH;
unsigned char g_macaddrLsb;
extern struct _usart1rxbuf g_usart1rxbuf;

//============= Extern Functions =====================
//- Utils
extern signed int yprintf(const char *pFormat, ...);
extern void stmI2cModuleConfig(I2C_TypeDef* I2Cx, u32 I2Cspeed);
extern void delayx(unsigned int ms);
extern void somedelay(volatile uint32_t nCount);
extern unsigned long micros();
unsigned long millis();
extern char *float2str(float x);
extern void PrintCharBsp(char c);//PrintChar(char c);
extern signed int printf(const char *pFormat, ...);

//Uarts
extern void stmUsart3_Init(unsigned int baud);
extern void usart6_init(unsigned int baud);
extern void stmUartLoop(unsigned char uartId, unsigned baud);
extern void stmUSART1ShimConf(uint32_t USART_BaudRate);
extern void stmUSART2ShimConf(uint32_t USART_BaudRate);
extern void stmUSART3ShimConf(uint32_t USART_BaudRate);

//Datong
extern void stm103_portTest();
extern int stmBlinkyLoop(void);
extern void stmBlinkyVeryFirstLoop(void);
extern void stmBlinkyAndBeepLoop(void);
extern void stmBlinkyAndPrintfLoop(void);
extern void stmDtmfGenLoop();
extern void stmBeepLoop(void);
extern void stmMCP3201Loop();
extern void stmQeiLoop(void);
extern void rngLoop(void);
extern uint32_t rngConfigAndGetRand(void);

extern void stmMCP3201Loop(); //ADC-spi
extern void stmMCP3208AdcLoop();//ADC-spi
extern void stmMCP2515Loop();
extern void stmMCP23008_Loop();
extern void tcm3105FskModemLoop(unsigned char uartId); //FSK-MODEM-300bps
extern void stmDmx512MasterLoop(void); //RS485-DMX512

//Sensors
extern void stmTC77_ReadTemperatureLoop(); 		//SPI
extern void stmLm75TempSensorI2cLoop (void); 	//I2C
extern void stmBmp280loop() ; 					//Barometer
extern void si7021_loop(); 						//Humidity
extern void pm2008i2c_loop();					//pm2008m DustSensor I2C

extern void stmAp3216Loop (void); 				//Ambient Lux /proximity Sensor
extern int stmAp3216_Init(unsigned char enALS, unsigned char enPS);
extern eResultStatus Ap3216_Show_PsValue_api();
extern void stmAPDS9960Loop (void);				//Ambient Lux /proximity/Gesture Sensor
extern void stmVL53L0X_loop();    				//Proximity Sensor (LIDAR)

extern void stmLIS3DH_Loop(); 					//3-axis accelerometer
extern uint8_t LIS3DH_readRegister8(uint8_t reg);
extern u8 stmLIS3DH_getInt1src();
extern void stmLIS3MDL_Loop(); 					//magnetometer
extern void stmMPU6050Loop();					//

extern void stmAs5600_Loop();					//Motor rotation counter hall sensor
extern short stmAs5600_GetDegree();

extern void dh11_loop();
extern int GP2Y_Loop(void); //dust sensor with adc

//Actuators
extern void stmRelayControlLoop(void);
extern void stmDualSolenoidControlLoop(void);

extern void stmTb6612Loop();					//Dual H-bridge DC Motor Driver
extern void stmStepper_Loop(void);				//Bit-bang Stepper
extern void stmA3967BipolarMotorLoop();			//Microstep Stepper Driver
extern void stmA3967GoStepsForward(u32 nStep);
extern void stmA3967GoStepsBackward(u32 nStep);
extern void stmA3967Conf();

extern stmAMIS30621_TMC211_LinLoop();			//LIN-based Stepper Driver Controller
extern void stmX27_Vid29_Init(unsigned int maxSteps);	//Guage stepper
extern void stmX27_Vid29_MoveTheNeedleAt(unsigned int pos);
extern void stmX27_Vid29_Loop(void);

//Automotive Network
extern int stmCanLoop(void);
extern int stmLinLoop(void);
//extern int ETH_SimpleTJA1100Loop(void);			//Automotive Ethernet PHY(NXP TJA1100)
//extern void stmRTL9K_TestLoop();				//Automotive Ethernet PHY(Realtek RTL9000)

//Ethernet
extern void stmEnc28J60EtherSpiLoop(); 			//SPI-10Mbps
extern int ETH_SimpleLoop(void); 				//with IP101 PHY
//extern 	int dtMdioLoop(void);
extern int stmMdioBitbangLoop(void);

//Ethernet Swith
//extern 	void Lan9355_init();
//extern void Lan9355_Config();
//extern void Lan9355_Loop();
//extern void Ksz8794_Loop();
//extern void Ksz8794_Basic_Loop();

//Display
extern void stmWs2812LEDloop();
extern 	void stmMax7219_ClockLoop();
//extern	void stmMax7219_4Digit_Loop(int nCS);
extern void stmMax7219_DotMatrix_Loop();
extern int lcd_config(void);
extern void Display_String(uint16_t x, uint16_t y, char *ptr,uint16_t color); //LCD
extern void LCDlogo(void);
extern void stmOzOled_Loop();
extern void stmHt16K33Loop();
extern void stmPcf8574I2cLoop (void);
extern void sccb_OV7670_loop(void);
extern int lcdLoop (void);

//== Clock/Frequency Generators
extern void stm_Si5328cLoop (void);
extern void DS3231rtc_loop();
extern void cs2300Config();
extern unsigned char stmAd9833_FreqGenLoop();
extern void stmRTCLoop();

//USB
extern void stmUsbInit();
extern int usbVcpLoop(void);
extern int usbLoop(void);

//Wireless
extern void stmRF433txLoop(void);
extern int stm433MHzLoop(void);
extern int stm433MHzWithUsartALoop(void);
extern void stmGpsLoop(unsigned char uartId);

#if (PROCESSOR == PROCESSOR_STM32F103C8T6)
extern void stmBeepPC13_setup(void);
extern void stmBeepPC13(u32 delay);
#else
extern void stmBeepPD14_setup(void);
extern void stmBeepPD14(u32 delay);
#endif

extern void stmCLCD_Loop();
//== Project ==========
extern int contiki_loop();

//PTP
extern int yEther_PTP_1588_8021AS_Loop(char *str);
extern void stm_ptp_mainloop();
extern int ETH_PTP8021asLoop(char *str);
extern void SysTickIntHandler_PTP(void);

extern void stmDrv8833Loop();
//Ethernet
extern int stmMdio407_107Loop(void);

//======== UTILS ============

//for using usart for debugging, set proper DEBUG_UART_INDEX in yInc.h
void yAssert(unsigned char x, char *str){
	if(!x){ //if false
		//do{
			printf("----ASSERT(%s)\r\n",str);
		//}while(1);
	}
}

/* Initialize SysTick to 1 ms.*/
/****************************************
 *SystemFrequency/1000      1ms         *
 *SystemFrequency/100000    10us        *
 *SystemFrequency/1000000   1us         *
 *****************************************/
void Init_SysTick(int resolutionInUsec){
  RCC_ClocksTypeDef RCC_Clocks;

  g_tickCnt = 0;

  SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);
  RCC_GetClocksFreq(&RCC_Clocks);
  if(resolutionInUsec == 1)
	  SysTick_Config(RCC_Clocks.HCLK_Frequency / 1000000);//1usec
  else if(resolutionInUsec == 10)
	  SysTick_Config(RCC_Clocks.HCLK_Frequency / 100000);//10usec
  else if(resolutionInUsec == 1000)
	  SysTick_Config(RCC_Clocks.HCLK_Frequency / 1000);//1msec
  else if(resolutionInUsec == 10000) //default
	  SysTick_Config(RCC_Clocks.HCLK_Frequency / 100);//10msec


  NVIC_SetPriority(SysTick_IRQn,0);

  delayms(10);

  	    /***************************************************************************
  	    NOTE:
  	         When using Systick to manage the delay in Ethernet driver, the Systick
  	         must be configured before Ethernet initialization and, the interrupt
  	         priority should be the highest one.
  	  *****************************************************************************/
  	  /* Set Systick interrupt priority to 0*/
  //	  NVIC_SetPriority (SysTick_IRQn, 0);

}

void SysTick_Handler(void){
	//lwip_Time_Update();//  Update the LocalTime by adding SYSTICKMS each SysTick interrupt
	//  Time_Update();
	//SysTickIntHandler_TEST();
	g_tickCnt++;

	if((g_tickCnt % 100) == 0){ //if((g_tickCnt % 1000) == 0){
		g_tickEvent = 1;
	}
#if (PROJ_FOR == PROJ_FOR_PTP) || (PROJ_FOR == PROJ_FOR_RSTP_PTP)
	SysTickIntHandler_PTP();
#endif
}

/*
SysTickIntHandler_LAN9355(){
	g_tickCnt++;
	if((g_tickCnt % 1000) == 0){
		g_tickEvent = 1;
	}
}

extern void SysTickIntHandler_PTP(void);
uint64_t tickTime=0;        //FreeRTOS Counts OS ticks (default = 1000Hz).
*/
/*
#ifdef NO_SYS
void SysTick_Handler(void){
#if(SWTICH_ID == SWITCH_LAN9355)
	SysTickIntHandler_LAN9355();
#else
	SysTickIntHandler_PTP();
#endif
}
#else
// This FreeRTOS callback function gets called once per tick (default = 1000Hz).
// ----------------------------------------------------------------------------
void vApplicationTickHook( void );

void vApplicationTickHook( void ) {
	SysTickIntHandler_PTP();
	++tickTime;
}
void vApplicationStackOverflowHook(void){
	printf("OV");
}
#endif
*/
//==========================================================================
/*
void SysTick_Handler(void){
	//lwip_Time_Update();//  Update the LocalTime by adding SYSTEMTICK_PERIOD_MS each SysTick interrupt
	//  Time_Update();
	//SysTickIntHandler_TEST();
	SysTickIntHandler_PTP();
}
*/



/* == For automotive electronics engineering Class =====================
void AutomotiveSensorActuatorProj(){
	float temperature;
	uint8_t int1_src;
	int saved_degree = 0;
	int degree;
	eResultStatus canStatus;

	g_INT1_LIS3DH = 0;
	g_INT2_LIS3DH = 0;
	//stm103_portTest();

	//Sensor Config. ==========================
	printf("LIS3DH accelerometer driver setup...");
    LIS3DH_BaseConfig();
    LIS3DH_init();
	printf("LIS3DH accelerometer driver setup Done.\r\n");
	delayms(100);

	//==Sensor AP3216
	//stmAp3216_Init(1, 1);

	//Motor Config. ==========================
	//stmTb6612_Config(10); //Dual DC Motor Driver
	stmA3967Conf(); //Bipolar Stepper Motor Driver.
	//stmX27_Vid29_Init(315*3); //MAXSTEPS

	//CAN/LIN Config ==========================
	stmCAN_Config();
	stmCAN_SetFilter();

	while(1){
        if(g_INT1_LIS3DH == 1)   	printf("INT1_LIS3DH\r\n");
        if(g_INT2_LIS3DH)       	printf("INT2_LIS3DH\r\n");
        if(g_INT1_LIS3DH == 1)//Int1
       	{
    		stmLedToggle();

       		printf("==================================\r\n");

    		LIS3DH_read_XYZ();

       		temperature = (float)LIS3DH_readTempFromADC3()/126.0; //Range = -40~+85 : 8 bit
        	printf("LIS3DH> Temp = %s Degree.\r\n ",float2str(temperature));

    		g_INT1_LIS3DH = 0;
    		g_INT2_LIS3DH = 0;

       		int1_src = stmLIS3DH_getInt1src(); //Clear INT1

        	if(int1_src == 0x48){
        		printf("LIS3DH> YH");
        		//stmTb6612_forwardBothMotor(100, 100);
        		stmA3967GoStepsForward(20);

        		canStatus = stmCAN_Send_Std();

        	}else if(int1_src == 0x44){
        	    printf("LIS3DH> YL");
        		//stmTb6612_backBothMotor(100,100);
        	    stmA3967GoStepsBackward(20);

        	    canStatus = stmCAN_Send_Std();

        	}else if(int1_src == 0x42){
        		printf("LIS3DH> XH");
        	}else if(int1_src == 0x41){
        		printf("LIS3DH> XL");
        	}

        	//degree = stmAs5600_GetDegree();
    		//printf("Degree = %d\r\n", degree);
        }

    	degree = stmAs5600_GetDegree();
    	if(degree == -1){
    		//no magnet
    	}else if(degree > saved_degree){
    		if((degree - saved_degree) > 20){
    	   		stmLedToggle();
    			//stmTb6612_forwardBothMotor(100, 100);
    			stmA3967GoStepsForward(20);
    			saved_degree = degree;

    			//stmX27_Vid29_MoveTheNeedleAt(50); //VID29

    			canStatus = stmCAN_Send_Std();

    			printf("AS5600> Degree = %u\r\n", (int)degree);
    		}
    	}else if(degree < saved_degree){
    		if((saved_degree - degree) > 20){
    	   		stmLedToggle();
    			//stmTb6612_backBothMotor(100,100);
    			stmA3967GoStepsBackward(20);
    			saved_degree = degree;

    			//stmX27_Vid29_MoveTheNeedleAt(100); //VID29

    			canStatus = stmCAN_Send_Std();

    			printf("AS5600> Degree = %u\r\n",  (int)degree);
    		}
    	}

    	//======== Proximity Sensors
    	//Ap3216_Show_PsValue_api();

    	//Can Receive Handler
    	//canStatus = stmCAN_Receive_by_Polling();
	}
}
*/




//=========== Mandatory the very first configuration for STM32F103 ==========
void dtInstall_DebugConsole(){
	// For using printf(), we activate UART1 of MCU with 115200bps ==================================
	// Also you should install TeraTerm Terminal Emulator on your PC/Notebook.
	// Connect the PC(via USB/UART Dongle) to MCU's USART1 pins with 115200 baud rate.
	// You also understand UART operation here.


#if ((PROCESSOR == PROCESSOR_STM32F103C8T6) || (PROCESSOR == PROCESSOR_STM32F103RCT6)|| (PROCESSOR == PROCESSOR_STM32F107VCT))
	// Setup USART1 for Debugging Console Output.
	if(DEBUG_UART_INDEX  == 1) //you can find this definition in yInc.h
		stmUsart1_Init(115200); //KONG
	else if(DEBUG_UART_INDEX  == 2)
		stmUsart2_Init(115200);
	else if(DEBUG_UART_INDEX  == 3)
		stmUsart3_Init(115200);
	//printf("STM32F10X: SYSCLK_Frequency(PLL)=%d(Should be 72MHz), HCLK_Frequency(should be 72MHz)=%d, HSE_Freq=25MHz \r\n",RCC_ClockFreq.SYSCLK_Frequency,RCC_ClockFreq.HCLK_Frequency);
	delayms(100);
#elif (PROCESSOR == PROCESSOR_STM32F407VGT6)
	if(DEBUG_UART_INDEX  == 2)
		stmUsart2_Init(115200); //KONG
	else if(DEBUG_UART_INDEX  == 3)
		stmUsart3_Init(115200);

	printf("STM32F407: SYSCLK_Frequency(PLL)=%d(Should be 168MHz), HCLK_Frequency(should be 168MHz)=%d, HSE_Freq=25MHz \r\n",RCC_ClockFreq.SYSCLK_Frequency,RCC_ClockFreq.HCLK_Frequency);
#elif (PROCESSOR == PROCESSOR_STM32F407VZT6)
	stmUsart3_Init(115200);
	printf("SYSCLK_Frequency(PLL)=%d(Should be 168MHz), HCLK_Frequency(should be 168MHz)=%d, HSE_Freq=25MHz \r\n",RCC_ClockFreq.SYSCLK_Frequency,RCC_ClockFreq.HCLK_Frequency);
#elif (PROCESSOR == PROCESSOR_STM32F401RET6)
	//stmUsart6_Init(115200);//401-M34
	stmUsart2_Init(115200);//401-M35
	printf("STM32F401: SYSCLK_Frequency(PLL)=%d(Should be 84MHz), HCLK_Frequency(should be 84MHz)=%d, HSE_Freq=25MHz \r\n",RCC_ClockFreq.SYSCLK_Frequency,RCC_ClockFreq.HCLK_Frequency);
#endif

	printf("============= HELLO KONG ================\r\n");
	printf("======= for Practical DataComm ==============\r\n");
}
/*
 *  for arinc429 - 6.4MHz Crystal
 *  // System Clock Configuration
void SystemClock_Config(void)
{

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL8;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);

  HAL_RCC_MCOConfig(RCC_MCO, RCC_MCO1SOURCE_PLLCLK, RCC_MCODIV_1);

  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);

  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);

}
 */
void dtVeryFirstMcuConfigAndInstallDebugConsole(){
	uint8_t ret;
	//SystemInit and Set its clock source
	RCC_ClocksTypeDef RCC_ClockFreq;

	SystemInit();
	//_init_ms();   //for delayms -- YOON
	delayms(10);
#if ((PROCESSOR == PROCESSOR_STM32F103C8T6) || (PROCESSOR == PROCESSOR_STM32F103RCT6) || (PROCESSOR == PROCESSOR_STM32F107VCT))

#else
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); // 4 bits for pre-emption priority. 0 bits for subpriority
	//RCC_HSEConfig(RCC_HSE_ON); //add
	//while(RCC_GetFlagStatus(RCC_FLAG_HSERDY)== RESET);//wait until HSE is ready.
#endif
	ret = RCC_GetSYSCLKSource();
	// @retval The clock source used as system clock. The returned value can be one of the following:
	//     - 0x00: HSI used as system clock
	//     - 0x04: HSE used as system clock
	//     - 0x08: PLL used as system clock
	RCC_GetClocksFreq(&RCC_ClockFreq);

#if (DEBUGG_CONSOLE == IS_USB)
	stmUsbInit(); //in Device Mode for Terminal Emulator Function (TBD)

#elif (DEBUGG_CONSOLE == IS_USART)
	dtInstall_DebugConsole();
#endif
	printf("STM32F103:SYSCLK=%d(be 72MHz)",RCC_ClockFreq.SYSCLK_Frequency);
	printf("HCLK(be 72MHz)=%d,HSE_Freq=8MHz \r\n",RCC_ClockFreq.HCLK_Frequency);
}

void stmUsingPB3_4_AsGPIO()
{
#if ((PROCESSOR == PROCESSOR_STM32F103C8T6) || (PROCESSOR == PROCESSOR_STM32F107VCT))

	//[VERY IMPORTANT] PB3's default function is JTDO and PB4's default function is JNTRST.
	//Thus we should remap it to general GPIO pin as the follows if needed.
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
    GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE); //PB3/PB4 Remap to GPIO
#if 0 //TEST
	//(b)Configure PB3 and PB4 as outputs for GPIO
    GPIO_InitTypeDef GPIO_InitStruct;
	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4;
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;// | GPIO_Mode_AF_PP;
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStruct);

    while(1){
    	{GPIO_SetBits(GPIOB, GPIO_Pin_3 | GPIO_Pin_4);}
    	delayms(100);
    	{GPIO_ResetBits(GPIOB, GPIO_Pin_3 | GPIO_Pin_4);}
    	delayms(100);
    }

#endif
#endif
}

extern void RTC_DS3231_now(struct _DateTime *dt) ;
extern stmGpsConfig(unsigned char uartId);
extern char stmGpsGetTimeOfDay(unsigned char uartId, struct minmea_sentence_rmc *rmc);
extern char *getStr_DaysOfTheWeek(struct _DateTime *dt);
extern unsigned int DateTime_unixtime(struct _DateTime *dt);
extern char stmGpsGetTimeOfDayAndDisplay(unsigned char uartId, struct minmea_sentence_rmc *rmc);
extern void RTC_DS3231_Adjust(struct _DateTime *dt); //set time

struct _ppsHoldOver g_ppsHoldOver;

#if (USE_EXTI4 == USE_EXTI4_GPSPPS)
//PB4 - GPSpps
void EXTI4_IRQHandler()
{
	if(EXTI_GetITStatus(EXTI_Line4) != RESET) {
		EXTI_ClearITPendingBit(EXTI_Line4);		// Clear the EXTI line 4 pending bit

		if(g_ppsHoldOver.lost_GPS_PPS){ //was lost, now received.
			g_ppsHoldOver.lost_GPS_PPS = 0;

		}
		//g_ppsHoldOver.GpsPpsTick = g_tickCnt + 100; //reload for next 1sec
		//g_ppsHoldOver.showTimeByRTCperSec = 1;


		// Toggle LED0
		GPIO_ToggleBits(GPIOC, GPIO_Pin_13); // ULED ON (PC13)
		//g_irq_ap3216 = 1;
	}
}
#endif

#if (USE_EXTI9_5 ==	USE_EXTI9_5_RTC )
//PA8-RTCpps
void EXTI9_5_IRQHandler()
{
	if(EXTI_GetITStatus(EXTI_Line8) != RESET) {
		EXTI_ClearITPendingBit(EXTI_Line8);		// Clear the EXTI line 8 pending bit

		if(g_ppsHoldOver.lost_GPS_PPS){ //was GPS lost, still lost. Thus we inform advance 1 sec by RTC.
			g_ppsHoldOver.showTimeByRTCperSec = 1;
		}

		//g_ppsHoldOver.RtcPpsTick = g_tickCnt + 100;//reload for next pps


		// Toggle LED0
		GPIO_ToggleBits(GPIOC, GPIO_Pin_13); // ULED ON (PC13)
		//g_irq_ap3216 = 1;
	}
}
#endif



//PROJ
extern char stmGpsDisplayTimeOfDay(unsigned char uartId, struct minmea_sentence_rmc *rmc);
extern unsigned char RTC_DS3231_isrunning(void);

void proj_wireless_gps_clock(){
	GPIO_InitTypeDef   GPIO_InitStruct;
    EXTI_InitTypeDef   EXTI_InitStructure;
	NVIC_InitTypeDef   NVIC_InitStructure;

	char str[16];
	char ret;
	struct minmea_sentence_rmc rmc;
	int ypos;
/*
	if(!g_bI2CModuleConfigDone){
		printf("Not I2C installed\r\n");
		return;
	}
*/
	  //ULED-pc13 setup
	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
	  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
	  GPIO_InitStruct.GPIO_Mode  = GPIO_Mode_Out_PP;
	  GPIO_InitStruct.GPIO_Pin   = GPIO_Pin_13;//GPIO_Pin_All ;
	  GPIO_Init(GPIOC, &GPIO_InitStruct);

	  while(1){
		  GPIO_SetBits(GPIOC, GPIO_Pin_13);
  		 delayms(1000);//somedelay(1000000);
	  		GPIO_ResetBits(GPIOC, GPIO_Pin_13);//
	  		delayms(1000);//somedelay(1000000);
	  }


	//PPS pins config(PB4-GPSpps and PA8-RTCpps)
	//(1) PB4-GPSpps
	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_4;		  // we want to configure Pb4
	  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPD; 	  // we want it to be an input
	  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;//this sets the GPIO modules clock speed
	  GPIO_Init(GPIOB, &GPIO_InitStruct);

	  //INT for PB4
	  GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource4);// Connect EXTI Line4 to PB4 pin
	  EXTI_InitStructure.EXTI_Line = EXTI_Line4;
	  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
	  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	  EXTI_Init(&EXTI_InitStructure);

	  NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;
	  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;
	  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01;
	  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	  NVIC_Init(&NVIC_InitStructure);

	  //(2) PA8-RTCpps
	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_8;		  	// we want to configure Pa8
	  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPD; 	  	// we want it to be an input
	  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;	//this sets the GPIO modules clock speed
	  GPIO_Init(GPIOA, &GPIO_InitStruct);

	  //INT for PA8
	  GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource8);// Connect EXTI Line8 to PA8 pin
	  EXTI_InitStructure.EXTI_Line = EXTI_Line8;
	  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
	  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	  EXTI_Init(&EXTI_InitStructure);

	  NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQn;
	  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;
	  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01;
	  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	  NVIC_Init(&NVIC_InitStructure);


	printf("GPS Config with USART2\r\n");
	stmGpsConfig(2);//unsigned char uartId);

	printf("DS3231 Config with I2C\r\n");

	//set time
	g_ppsHoldOver.firstToDSetDoneByGps = 0;
	g_ppsHoldOver.DateTime.yOff = 20;
	g_ppsHoldOver.DateTime.m = 2;
	g_ppsHoldOver.DateTime.date = 6;
	g_ppsHoldOver.DateTime.day = 3;
	g_ppsHoldOver.DateTime.hh = 9;
	g_ppsHoldOver.DateTime.mm = 43;
	g_ppsHoldOver.DateTime.ss = 20;
	DS3231_setup(NULL);//&g_ppsHoldOver.DateTime);

	g_ppsHoldOver.GpsPpsTick = 0;
//	g_ppsHoldOver.RtcPpsTick = 0;
	g_ppsHoldOver.lost_GPS_PPS = 0;
	g_ppsHoldOver.showTimeByRTCperSec = 0;

	Init_SysTick(10000);// 10msec Tick

	if (RTC_DS3231_isrunning())
			g_ppsHoldOver.firstToDSetDoneByGps = 1;

	ypos= 3;
	while(1){

		//Although no GPS_PPS, the RMC msg still may be received...How to do?


		if(g_tickCnt > (g_ppsHoldOver.GpsPpsTick + 5)){ //No GPS PPS in 50msec
			g_ppsHoldOver.lost_GPS_PPS = 1;
			printf("lost GPS pps\r\n");
		}

		//GPS time
		if(!g_ppsHoldOver.lost_GPS_PPS){
		    if(stmGpsGetTimeOfDay(2, &rmc) == ERR_OK){
				g_ppsHoldOver.GpsPpsTick = g_tickCnt + 100; //reload for next 1sec

				g_ppsHoldOver.DateTime.yOff = rmc.date.year;
				g_ppsHoldOver.DateTime.m = rmc.date.month;
				g_ppsHoldOver.DateTime.date = rmc.date.day;
				g_ppsHoldOver.DateTime.hh=rmc.time.hours;
				g_ppsHoldOver.DateTime.mm=rmc.time.minutes;
				g_ppsHoldOver.DateTime.ss = rmc.time.seconds;

				RTC_DS3231_Adjust(&g_ppsHoldOver.DateTime); //set current on rtc

				stmGpsDisplayTimeOfDay(2, &rmc);
				stmOzOLED_printString("by GPS",1,5,15);

				printf("GPSTIME=%u.%u.%u %u:%u:%u\r\n", rmc.date.year + 2000,rmc.date.month,rmc.date.day,rmc.time.hours,rmc.time.minutes, rmc.time.seconds);

				if(!g_ppsHoldOver.firstToDSetDoneByGps)	g_ppsHoldOver.firstToDSetDoneByGps = 1;
		    }else
		    	continue;
		}else{ //lost_GPS_PPS == 1
			if(g_ppsHoldOver.showTimeByRTCperSec) //show Time per 1sec by RTC
			{
				g_ppsHoldOver.GpsPpsTick = g_tickCnt + 100; //reload for next 1sec
				g_ppsHoldOver.showTimeByRTCperSec = 0; //for next round

				if(!g_ppsHoldOver.firstToDSetDoneByGps)	{
					printf("Connect GPS\r\n");
					stmOzOLED_printString("--:--:--",1,3,15);
					stmOzOLED_printString("ConnectGPS",1,7,15);
					continue;
				}

				RTC_DS3231_now(&g_ppsHoldOver.DateTime);//Get RTC time
				printf("NowTime = ");
				printf("%u-",g_ppsHoldOver.DateTime.yOff + 2000);
				printf("%u-",g_ppsHoldOver.DateTime.m);
				printf("%u ",g_ppsHoldOver.DateTime.date);
				printf("(%s) ", getStr_DaysOfTheWeek(&g_ppsHoldOver.DateTime));//daysOfTheWeek[DateTime_dayOfTheWeek(&DateTime)]);
				printf("%u:",g_ppsHoldOver.DateTime.hh);
				printf("%u:",g_ppsHoldOver.DateTime.mm);
				printf("%u\r\n",g_ppsHoldOver.DateTime.ss);
				//=== unix time since 1970.1.1 midnight
				printf("UnixTime= %us\r\n", DateTime_unixtime(&g_ppsHoldOver.DateTime) );
				sprintf(str,"%02u:%02u:%02u",g_ppsHoldOver.DateTime.hh,g_ppsHoldOver.DateTime.mm, g_ppsHoldOver.DateTime.ss);
				stmOzOLED_printString(str,1,3,15);
				stmOzOLED_printString("by RTC",1,5,15);
			}
		}
		//delayms(1000);
	}

	//stm_RF24_loop(); //stmRF433txLoop();
}
//audio
extern void stmTea5767FmLoop(void);
extern void stmTea5767FmWithWm8731Loop(u8 uselineormic, u8 bypassEn);
void stmBeep_setup(void);
void stmBeep(u32 delay);
void KT0803L_FMstation_loop();

extern int MOT_BLDC_Mcp8063Loop(void);
extern int MOT_BLDC_Drv8313Loop(void);
extern int MOT_BLDC_BgcLoop(void);
extern int MOT_ServoLoop(void);

extern void stmMCP23S17_Loop();
extern void stmMax7219_4Digit_Loop();
extern void stmSpiSt7735HY18LcdLoop();
extern void ST7735_initConfig();
extern void ST7735_displayValue(unsigned char x0,unsigned char y0, unsigned char val);
extern void  ST7735_displayString(unsigned char x0,unsigned char y0,unsigned char *s);

extern void stmVL53L0X_ConfigAndInit();
extern short stmVL53L0X_readRange();

extern void HMC5883LLoop();
extern void L3G4200Loop(); //Gyro : angular sensor
extern void stmADXL345Loop(); //gravity sensor
extern void L3GD20H_GYRO_Loop();
extern void bmp180Loop();
extern void stmLIS3MDL_Loop();

//Magnetometer (LIS3MDL and HMC5883L)
extern char stmLIS3MDL_MAG_ConfIo_Init();
extern char stmLIS3MDL_MAG_GetAxes(float *fData);
extern void stmHMC5883L_MAG_Init();
extern char stmHMC5883L_MAG_GetAxes(float *f_headingRad, float *f_headingDegrees);

//GYRO - Angular Rate Sensors (L3GD20H and L3G4200)
extern char stmL3GD20H_GYRO_ConfIo_Init(void);
extern void stmL3GD20H_GYRO_ReadXYZAngRate(float *pfData);
extern void stmL3G4200_GYRO_Init();
extern void stmL3G4200_GRYO_Get_XYZ(short xyz[]);

//ACCEL - Gravity Sensors (ADXL345)
extern void stmADXL345_ACCEL_Init();
extern void stmADXL345_ACCEL_ReadXYZ(short *acc);

//Barometer - BMP280, and BMP180...
extern void  stmBmp280_BARO_Init();
extern float stmBmp280_BARO_readPressure(void);
extern float stmBmp280_BARO_readAltitude();
extern float stmBmp280_BARO_readTemperature(void);

//6DOF
void stmMPU6050_ACCEL_GYRO_Init();
int  stmMPU6050_ACCEL_GYRO_read(int startReg, unsigned char *buffer, int size); //acc(xyz)+temp+gyro(xyz)


//Motor
void stmMcp8063BldcLoop(void);


//avioincs
extern void stmArinc429_TransmitterLoop();
extern void stmArinc429_ReceiverLoop();
extern void tca8418_loop();

void proj_gpws()
{
	char str[10];
	short range;

	stmBeep_setup();
	stmVL53L0X_ConfigAndInit();
#if (PROCESSOR == PROCESSOR_STM32F103RCT6)
	ST7735_initConfig();
	ST7735_displayString(1,144,"GPWS");
	ST7735_displayString(1,152,"Proximity : ");
#endif
	while(1){
		range = stmVL53L0X_readRange();
		if(range > 0){
			sprintf(str,"%03u mm",range);
#if (PROCESSOR == PROCESSOR_STM32F103RCT6)
			ST7735_displayString(80,152,str);//ST7735_displayValue(80, 152, range);
#endif
			if(range < 200){
				if(range > 120){
					stmBeep(70);
					delayms(500);
				}
				else if(range > 80){
						stmBeep(70);
						delayms(200);
				}else{
					stmBeep(70);
					delayms(100);
				}
			}
		}
		delayms(100);
	}
}

void proj_primary_radar(){

}

void proj_pfd(){

}

extern void tca8418_setup(void);
extern char tca8418_readKeypad(unsigned char *key, unsigned char *row, unsigned *col);

void proj_mcdu_with_Keypad_LCD(){
	char str[10];
	short range;

	unsigned char key, row, col;
	char none_up_down;

	//I2c config
	if(!g_bI2CModuleConfigDone)
	{
#if (PROCESSOR == PROCESSOR_STM32F407VZT6)
		  gI2Cx = I2C2;
#else
		  gI2Cx = I2C1;
#endif
		printf("I2C Init...");
		stm_I2C_Init(gI2Cx,400000);//400Kbps
		g_bI2CModuleConfigDone = 1;
		printf("Done.\r\n");
	}

	stmBeep_setup();

	tca8418_setup();

	//stmVL53L0X_ConfigAndInit();
#if (PROCESSOR == PROCESSOR_STM32F103RCT6)
	ST7735_initConfig();
	ST7735_displayString(1,144,"MCDU");
	//ST7735_displayString(1,152,"Proximity : ");
#endif
	while(1){

		none_up_down = tca8418_readKeypad(&key, &row, &col); 				//Get first keycode from FIFO
		if(none_up_down == 1){
			printf("%02u=(%u:%u)(row,col) Key Pressed\r\n",key, row, col );
			sprintf(str,"(%u:%u)", row, col );
#if (PROCESSOR == PROCESSOR_STM32F103RCT6)
			ST7735_displayString(80,152,str);//ST7735_displayValue(80, 152, range);
			stmBeep(70);
#endif

		}else if(none_up_down == 0){
			printf("%02u=(%u:%u)(row,col) Key UnPressed\r\n",key, row, col );
		}
		else{ //Not happend
			//printf("Nothing\r\n");
		}

/*
		range = 230;//stmVL53L0X_readRange();
		if(range > 0){
			sprintf(str,"%03u mm",range);
#if (PROCESSOR == PROCESSOR_STM32F103RCT6)
			ST7735_displayString(80,152,str);//ST7735_displayValue(80, 152, range);
#endif
			if(range < 200){
				if(range > 120){
					stmBeep(70);
					delayms(500);
				}
				else if(range > 80){
						stmBeep(70);
						delayms(200);
				}else{
					stmBeep(70);
					//delayms(100);
				}
			}
		}
		delayms(100);
*/
	}
}

void proj_adc(){

}
void proj_arinc429(){

}
extern void dtmf_loop(void);
extern void stmSn76489Loop(void);
extern void stmMCP4725_Loop();
extern void stmMCP4706_Loop();
extern void stmHd44780_Pcf8574_Clcd_Loop();
extern void pidLoop(void);
//========================================== THE MAIN =====================================
int main(void)
{
	int i = 0;
	uint8_t ret;
	int x;
	char str[12];
	unsigned short rdval;

	//============= Preliminary experiment ================================

	//stmUsingPB3_4_AsGPIO();

	//Configure the basic MCU settings, and install UART port for debugging.
	dtVeryFirstMcuConfigAndInstallDebugConsole();


	//(0)
	stmBlinkyAndPrintfLoop();
	//I2C Config.
	if(!g_bI2CModuleConfigDone){
#if (PROCESSOR == PROCESSOR_STM32F407VZT6)
		  gI2Cx = I2C2;
#else
		  gI2Cx = I2C1;
#endif
	}

	  printf("I2Cx Init with 100Kbps...");
	  stm_I2C_Init(gI2Cx,I2C_SPEED);//100Kbps
	  g_bI2CModuleConfigDone = 1;

	  //pidLoop();

	  //stmHd44780_Pcf8574_Clcd_Loop();

	  //stmMCP4706_Loop() ; //OK
	 // stmAd9833_FreqGenLoop();//OK

	  //install systick.
	  //Init_SysTick(10000);// 10msec Tick


	 // stmMCP23S17_Loop();
	//stmSn76489Loop();
/*

	GPIO_InitTypeDef GPIO_InitStruct;
	//PB4 - KONG-STM32F103C8T6 -- NEED PinRemap : GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_1;// | GPIO_Pin_11;
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;//this sets the GPIO modules clock speed
	GPIO_Init(GPIOB, &GPIO_InitStruct);

	//GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);

	while(1){
	GPIO_SetBits(GPIOB, GPIO_Pin_1);// | GPIO_Pin_11);
	delayms(100);
	GPIO_ResetBits(GPIOB, GPIO_Pin_1);// | GPIO_Pin_11);
	delayms(100);
	}
*/


	//audio
	//dtmf_loop();
	//KT0803L_FMstation_loop();
	//stmTea5767FmLoop();//u8 uselineormic, u8 bypassEn)
	//stmTea5767FmWithWm8731Loop(1, 1);

	//stmMax7219_DotMatrix_Loop();
	//tca8418_loop();

	//stmSpiSt7735HY18LcdLoop();
	//stmVL53L0X_loop();

	//Magnetometer
	//stmLIS3MDL_Loop();
	//stmHMC5883LLoop(); //Working
	//stmQMC5883Loop();
	//L3G4200Loop();      //angular gyro sensor
	//L3GD20H_GYRO_Loop();//g-sensor

	//stmLIS3DH_Loop();   //accelero
	//stmADXL345Loop();   //accelero

	//stmMPU6050Loop();//OK

	//stmBmp280Loop();



	//stm_RF24_loop();

	//Motors
	//stmMcp8063BldcLoop();

	//Avionics========================
	//Gimbal
	//MOT_BLDC_Mcp8063Loop();
	// MOT_BLDC_Drv8313Loop();
	 //MOT_BLDC_BgcLoop();
	//proj_mcdu_with_Keypad_LCD();
	//proj_gpws();
	//proj_wireless_gps_clock(); //Kim Min-Ah
	//stmArinc429_TransmitterLoop();
	//stmArinc429_ReceiverLoop();
	//tca8418_loop();

#ifdef USE_OLED

	//(5-2) OLED Display with I2C
	stmOzOLED_init("HELLO KONG");
#endif

	  //stmRTCLoop();
	  //stmBlinkyAndBeepLoop();



#if 0
	//(1) Entry level Test ===================================
	//(1-1) LED Blinking
	//stmBlinkyVeryFirstLoop();

	//(1-2) Blink and Beep
	//stmBlinkyAndBeepLoop();

	//(1-3) GPIO Test
	//stm103_portTest();

	//(1-4) Beep
	//stmBeepLoop();

	//(2)============= UART =================================
	//(2-1) Understand printf operation.
	//You shoud find the start and stop bits with oscilloscope.
/*    i= 0;
	while(1){
		printf("HELLO KONG(%u)\r\n",i);
		//Tracing the operation of the printf() with breakpoint tool,
		//you can see the printf uses UART send operation.
		delayms(1000);
		i++;
	}
*/
	//(2-3) TEST UART. Change the baud rate, stop bit configuration.
#else

#endif
	//(3)=============== UART and RS485 ===========================================
	//stmUsartTestLoop(); //USART1
	//stmDmx512MasterLoop(); //DMX512-RS485

	//(5)============== I2C Sensors =======================================
	//(5-1) LM75 I2C Temperature Sensor
	//stmLm75TempSensorI2cLoop();

#ifdef USE_OLED
	//(5-2) OLED Display with I2C
	//stmOzOLED_init("HELLO KONG");
	//stmOzOled_Loop();
#endif

	//(5-3) Magneto Sensor with I2C
	//stmLIS3MDL_Loop();

	//(5-4) Gyro Sensor with I2C
	//stmLIS3DH_Loop(); //M35

	//(5-5) IMU+Gyro Sensor with I2C
	//stmMPU6050Loop();//OK

	//(5-6) BMP280 Atmosphere Pressure Sensor
	//stmBmp280loop() ; //altitude err???
	//bmp180Loop();

#if (USE_EXTI9_5 ==	USE_EXTI9_5_AP3216)
	//(5-7) AP3216 Ambient Luminicent Sensor
	//stmAp3216Loop();
#elif (USE_EXTI9_5 ==	USE_EXTI9_5_APDS9960)
	//(5-8) APDS9960 Gesture and Ambient Luminicent Sensor
	//stmAPDS9960Loop();
#endif
	//(5-9) LADAR Distance Measuring Sensor
	//stmVL53L0X_loop();//Working

	//(5-10) Dust sensor
	//pm2008i2c_loop();
	//GP2Y_Loop();

	//(5-11) Humidity Sensor - Working
	//si7021_loop();
	//dh11_loop();

	//(5-10) LED Driver
	//stmPcf8574I2cLoop();//
	//stmWs2812LEDloop(); //LED Array
	//stmOzOled_Loop(); //OLED
	//stmHt16K33Loop(); //Dot-matrix LED

	//(5-11) CLCD
	//stmCLCD_Loop();

	//(6) SPI =================================
	//(6-1) TC77 SPI Temperature Sensor
	//stmTC77_ReadTemperatureLoop();

	//(6-2) MCP3201/ MCP3208 ADC
	//stmMCP3201Loop();		//ADC-SPI
	//stmMCP3208AdcLoop();	//ADC-SPI

	//(6-3) MAX7219 7-Seg LED Driver
	//stmMax7219_ClockLoop(); //--OK
	//stmMax7219_4Digit_Loop(0);

	//stmMax7219_4Digit_Loop(1);

	//(7) ====== Actuators
	//(7-1) Actuator-Relay Control
	//stmRelayControlLoop();

	//(7-2) Actuator-Solenoid Control
	//stmDualSolenoidControlLoop();

	//(7-3) Uipolar DC Motor
	//stmUnipolarMotorLoop(); //Working

	//(7-4) TB6612-Dual DC Motor Control
	//stmTb6612Loop(); //Working

	//(7-5) Stepper control - Bitbang
	//stmStepper_Loop();//OK

	//(7-6) Stepper control - Allegro A3967 Microstep controller
	//stmA3967BipolarMotorLoop(); //OK
	//MOT_ServoLoop();


	stmDrv8833Loop();
	//(7-7) Instrument Pannel Guage - Step Motor
	//stmX27_Vid29_Loop();//TBD

	//(7-8) AS5600 Motor Sensor
	//stmAs5600_Loop();

	//(8)Wireless (Options)
	//(8-1) 433MHz
	//stm433MHzWithUsartALoop();
	//stm433MHzLoop();
	//DS3231rtc_loop();
	//stmGpsLoop(2);//3); //OK
	//stm_RF24_loop(); //stmRF433txLoop();

	//(9) IoT Applications
	//TBD

	//(10) Ethernet/Internet ===============================
	//(10-1) Ethernet
	stmEnc28J60EtherSpiLoop();

	//(10-2) Web over Ethernet
	//stmUipHttpdLoop(); //with Enc28J60 Ethernet

	//(10-3) Wiznet TCP/IP Controller with Ethernet/SPI
	//W5500_loop();



#if (PROCESSOR == PROCESSOR_STM32F107VCT)
	//(10-4) -- Only For STM32F407/107
	//	stmMdio407_107Loop();
	//ETH_SimpleIP101Loop();//OK
	//Ksz8794_Basic_Loop();//Ksz8794_Loop();//OK
	//dtMdioLoop();//OK
	//Lan9355_Loop(); //OK
	//Lan9355_Tap_Loop(); //OK
	//ETH_SimpleLoop();//OK
#endif
	stmMdioBitbangLoop();
    //stmMdioGeneralPhy_Loop();
	//(11) Automotive & IT Fusion Project ===================
	//AutomotiveSensorActuatorProj();

	//(11-2) CAN
	//stmCanLoop();
	//stmMCP2515Loop(); //CAN-SPI

	//(11-3) LIN
	//stmLinLoop();
	//stmAMIS30621_TMC211_LinLoop(); //OK

	//(11-4) Automotive Ethernet
	//ETH_SimpleTJA1100Loop(); //--OK
	//yRTL9Kmc_Loop();
	//stmRTL9K_TestLoop();

	//...

	//(4) DataCommun Basic Topics
	//(4-1) FSK Modem
	//tcm3105FskModemLoop(1); //NEED NOTE. USART1 can not support this 1200baud. We should use USART3 for this low speed modem.

	//(4-2) DTMF
	//stmDtmfGenLoop();

	//(20) ETC
	//stmQeiLoop(); //OK
	//stmMCP23008_Loop(); //I2C
	//rngLoop();
	//stmUartLoop(3, 9600);
	//stmAd9833_FreqGenLoop();//OK
	//stm_Si5328cLoop ();

	//usbVcpLoop(); //Partially OK


/* ============ TBD =======================

	//==projects
	//stm_Si5351aProjLoop();
	//stm_Si5328cProjLoop();
	//stm_Si5351aLoop();
	//stmSyncProjLoop(3);
	//stmSi5351aLoop();
	//randNum32 = rngConfigAndGetRand();
	//printf("\r\n=== randNum32=%d\r\n",randNum32);
	//randNum32 = 0xfe;
	//delayms(1000);

	//USART1 test loop
	Usart1GetStrNonBlockingInit();
	while(1){
		//Usart1GetStr(str);//rscanf("%d",&x);printf("x=%x\r\n",x);
		if(Usart1GetStrNonBlocking()!=-1){
			printf("str=%s\r\n",g_usart1rxbuf.buf);
		}
	}
	while(1){
		PrintCharBsp('A');
		printf("%d\r\n",i);
		i++;
    }
*/


		//===========for assigning different MAC/IP address per node.========
		g_macaddrLsb = 1;
	#if 0 //USE_UBUTTON
		//User Button Setup
		//PC5 - KONG-STM32F401-M35 (Active High)
		//PD11 - KONG-STM32F407-M36 (Active Low)
		stmUser_Button_GPIO_setup();
		delayms(100);
		if(stmUserButton_Read()){
			g_macaddrLsb = 1;
			g_ip_addr3 = 101;
		}else{
			g_macaddrLsb = 0; //PUSHED. Active Low.
			g_ip_addr3 = 100;
		}
	#else
		#if USE_EXT_SELECTOR //for assigning different MAC/IP address per node.
			#ifdef USE_MCP23008 // If we use Rotary Switch Module.
				stmMCP23008_Init();
				g_macaddrLsb = stmMCP23008_ReadGpio();
				printf("MCP23008>ReadValue=0x%02x(%u)\r\n",g_macaddrLsb,g_macaddrLsb);
			#else
				//PC0 for selector input.//Root/Leaf Selection with PC0 pin input.
				GPIO_InitTypeDef   GPIO_InitStruct;
				RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
				GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;		  // we want to configure PC0
				GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN; 	  // we want it to be an input
				GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;//this sets the GPIO modules clock speed
				GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;   // this sets the pin type to push / pull (as opposed to open drain)
				GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;    // this enables the pullup resistor --> we want to detect a low level
				GPIO_Init(GPIOC, &GPIO_InitStruct);

				delayms(100);

				if(GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_0)){ //Leaf Nodes
					g_macaddrLsb = 1;
					g_ip_addr3 = 101;
				}
				else{ //Root Node
					g_macaddrLsb = 0;
					g_ip_addr3 = 100;
				}
			#endif
		#endif
	#endif

		printf("g_macaddrLsb = %d\r\n",g_macaddrLsb);
		//=============== PROJECTS =========================================
	#if	(PROJ_FOR == PROJ_FOR_RSTP)//==================== RSTP =====================================
		rstp_main (); //RSTP TEST OK
		//stmKszRstpPtpLoop();
		//stmRstpPtpLoop("RSTP_PTP");
	#elif (PROJ_FOR == PROJ_FOR_COSEM) //============================== COSEM =====================================
		//kosemSrvTestLoop();
		//cosemServerLoop();
		//cosemClientLoop();//int argc, char* argv[])
	#elif (PROJ_FOR == PROJ_FOR_CONTIKI) //============================== CONTIKI =====================================
		//contiki_loop(); //OK..Woking with ENC60 SPI Ethernet (RPL OK. 2018.06.05)
		//stmUipWebServerLoop(); //with uip in contiki -- OK
		//httpd_loop(); //-- ???//contiki_main(); //---???
	#elif (PROJ_FOR == PROJ_FOR_PTP)//============================= PTP =========================================
		stm_ptp_mainloop();
	#else
		//ETH_SimpleIP101Loop();//OK
	#endif

}
